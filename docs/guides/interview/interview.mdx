import Title from '@/components/my';


<Title text="一些常见的面试题"/>
:::note
这是一个 `note` 类型的 `block`
:::
## 防抖截流
### 防抖
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        #inputField {
            padding: 8px;
            font-size: 16px;
            width: 300px;
        }
        #output {
            margin-top: 10px;
            color: #333;
        }
        </style>
</head>
<body>
    <h2>输入事件模拟（带防抖）</h2>
    <input type="text" id="inputField" placeholder="请输入内容...">
    <div id="output">结果将显示在这里</div>
    <script src="./debounce.js"></script>
</body>
</html>
```
```js
// 防抖函数用于限制函数的执行频率，常用于处理高频触发的事件（如窗口调整、输入框输入等），确保在事件停止触发一段时间后才执行一次。
function debounce(fn, delay) {
    let timer = null
    return function (...args) {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            fn(...args)
            timer = null
        }, delay)
    }
}
// 获取 DOM 元素
const inputField = document.getElementById('inputField');
const output = document.getElementById('output');
// 示例1: 模拟输入事件
const logInput = debounce((value) => {
    output.textContent = `处理后的输入: ${value || '无内容'}`;
    console.log(`输入值: ${value}`);
}, 500);

 
// 监听输入事件
inputField.addEventListener('input', (event) => {
    const value = event.target.value;
    logInput(value);
});
// // 示例2: 窗口调整事件
const handleResize = debounce(() => {
    console.log("窗口大小调整完成");
}, 300);

window.addEventListener("resize", handleResize); // 调整窗口时，只在停止调整 300ms 后执行
```
### 截流
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

</head>
<body>
    <input type="text" id="input">
    <div id="content">content:</div>
</body>
<script type="text/javascript">
    // 更清晰的实现（修正解构赋值问题）
function handler() {
    const inputElement = document.getElementById("input");
    document.getElementById("content").innerHTML = `内容: ${inputElement.value}`;
}

// 标准节流函数实现（保留上下文绑定能力）
const throttle = (fn, wait) => {
    let timer;
    return function (...args) {
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(this, args); // 绑定正确的 this 上下文
                timer = null;
            }, wait);
        }
    };
};
document.addEventListener('input',throttle(handler,300))
</script>
</html>
```
### 区别
<table className="block bord...">{/*
*/}<tbody>{/*
*/}<tr>
  <th>维度</th>
  <th>防抖(Debounce)</th>
  <th>节流(Throttle)</th>
</tr>{/*
*/}<tr>
  <td>**核心目标**</td>
  <td>确保最终状态稳定后执行</td>
  <td>确保固定间隔内最多执行一次</td>
</tr>{/*
*/}</tbody>{/*
*/}</table>

<details>
<summary>📌 使用场景说明</summary>

- `防抖`：适用于需要等待用户停止操作后执行的场景（如搜索框输入联想）
- `节流`：适用于需要限制操作频率的场景（如窗口resize事件、滚动事件）
</details>
[继承和原型链]( https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain )
## Promise
[ revealing constructor ]( https://blog.domenic.me/the-revealing-constructor-pattern/ )
Promise 的实现
```js
class MyPromise {
  // Promise 构造函数，接收一个 executor 执行器函数
  constructor(executor) {
    // 初始状态为 pending，表示未完成状态
    this.state = 'pending';
    // 当状态变为 fulfilled 时存储成功结果
    this.value = undefined;
    // 当状态变为 rejected 时存储失败原因
    this.reason = undefined;
    // 存储异步执行时注册的成功回调
    this.onFulfilledCallbacks = [];
    // 存储异步执行时注册的失败回调
    this.onRejectedCallbacks = [];

    // 定义内部的 resolve 函数，负责将状态变为 fulfilled
    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        // 异步调用所有成功的回调，保证 then 中的回调都是异步执行的
        setTimeout(() => {
          this.onFulfilledCallbacks.forEach(fn => fn(value));
        }, 0);
      }
    };

    // 定义内部的 reject 函数，负责将状态变为 rejected
    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        // 异步调用所有失败的回调
        setTimeout(() => {
          this.onRejectedCallbacks.forEach(fn => fn(reason));
        }, 0);
      }
    };

    // 立即执行 executor，并传入 resolve 和 reject 函数
    // 如果执行器抛出异常，则捕获异常并调用 reject
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  // then 方法实现：接收成功和失败的回调函数
  then(onFulfilled, onRejected) {
    // 如果用户没有提供对应的回调函数，则设置默认值
    // 默认成功回调是返回传入的值，默认失败回调是将错误抛出
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected  = typeof onRejected  === 'function' ? onRejected  : reason => { throw reason };

    // 返回一个新的 Promise 以实现链式调用
    return new MyPromise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        // 如果当前状态为 fulfilled，异步执行成功回调
        setTimeout(() => {
          try {
            // 执行 onFulfilled 回调并获取返回值
            const result = onFulfilled(this.value);
            // 通过返回值 resolve 新的 Promise，实现链式传递
            resolve(result);
          } catch (error) {
            // 如果回调中抛出异常，则调用 reject
            reject(error);
          }
        }, 0);
      } else if (this.state === 'rejected') {
        // 如果当前状态为 rejected，异步执行失败回调
        setTimeout(() => {
          try {
            const result = onRejected(this.reason);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else if (this.state === 'pending') {
        // 如果当前状态为 pending，则将回调存入对应的队列中，等待状态改变后执行
        this.onFulfilledCallbacks.push((value) => {
          try {
            const result = onFulfilled(value);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        });
        this.onRejectedCallbacks.push((reason) => {
          try {
            const result = onRejected(reason);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        });
      }
    });
  }
}

```
1. 状态管理与数据存储
状态变量（state）
Promise 内部有三个状态：

pending（等待）：初始状态，表示操作尚未完成。

fulfilled（已成功）：操作成功完成。

rejected（已拒绝）：操作失败。

结果存储
当 Promise 状态改变时，成功的结果存储在 value 中，而失败的原因存储在 reason 中。这允许后续通过 then 方法获取对应的结果。

回调队列
当 Promise 处于 pending 状态时，用户可能调用 then 注册回调函数。此时，由于 Promise 尚未完成，就无法立即执行回调，因此需要将成功回调存放在 onFulfilledCallbacks 数组中，将失败回调存放在 onRejectedCallbacks 数组中。

2. 构造函数和执行器
执行器函数（executor）
构造函数接收一个执行器 executor，并立即执行该函数，同时传入内部封装好的 resolve 和 reject 函数。如果 executor 中抛出异常，会自动调用 reject。

resolve 和 reject
这两个方法只允许从 pending 状态转变到最终状态（fulfilled 或 rejected），这保证了 Promise 的状态一旦改变就不可再变。
在状态改变后，通过 setTimeout 异步调用注册在回调队列中的回调函数，确保所有 then 中的回调都是异步执行的（符合规范）。

3. then 方法及链式调用
参数处理
then 方法接受两个参数，分别为成功回调 onFulfilled 和失败回调 onRejected。如果用户没有传入相应的回调，会采用默认行为：

成功回调默认返回原值。

失败回调默认抛出错误，使错误能被后续的 catch 捕获。

状态处理
在调用 then 时，根据当前 Promise 的状态：

如果状态已经确定（fulfilled 或 rejected），则使用 setTimeout 异步调用相应的回调，并获取回调返回值，然后通过调用返回的新 Promise 的 resolve 或 reject 将结果传递出去。

如果状态还未确定（pending），则将回调函数存储到对应的队列中。一旦状态改变时，这些回调会被依次调用，并且通过返回值来决定新 Promise 的状态。

链式调用
每次调用 then 都返回一个新的 Promise，这样就可以实现链式调用。通过在新 Promise 的 executor 内部，根据上一次的回调执行结果决定调用 resolve 还是 reject，从而使得结果能逐层传递。

4. 异步执行
为了确保 Promise 的行为符合规范，所有回调函数都要异步执行，即使 Promise 已经处于确定状态，也通过 setTimeout 延迟执行。这是为了保证在代码执行过程中，注册回调的代码先运行完成，从而避免同步调用带来的问题。

小结
这个示例实现涵盖了 Promise 的基本特性：

状态不可逆转：状态从 pending 转变为 fulfilled 或 rejected 后不会改变。

回调注册与执行：支持在状态未确定时注册回调，状态改变后异步执行所有对应回调。

异常处理：在执行器函数和回调中抛出的异常会正确捕获并传递给后续的 reject。

链式调用：通过 then 方法返回新的 Promise 实现链式调用，允许连续处理异步操作。

