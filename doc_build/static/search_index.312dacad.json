[{"id":0,"title":"mini-react","content":"#\n\n\n\n\nvdom js object#\n\ntype props children\n\n\n\n\n修改抽离一小部分#\n\n\n\n\n动态创建DOM#\n\n\n\n\n创建render函数#\n\n\n\n * 优化\n\n","routePath":"/my-rspress-app/article/article","lang":"","toc":[{"text":"vdom js object","id":"vdom-js-object","depth":3,"charIndex":5},{"text":"修改抽离一小部分","id":"修改抽离一小部分","depth":3,"charIndex":46},{"text":"动态创建DOM","id":"动态创建dom","depth":3,"charIndex":60},{"text":"创建render函数","id":"创建render函数","depth":3,"charIndex":73}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"","content":"","routePath":"/my-rspress-app/components/Mermaid","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"","content":"","routePath":"/my-rspress-app/components/MyComponent","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"","content":"","routePath":"/my-rspress-app/components/my","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"","content":"","routePath":"/my-rspress-app/components/process","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"命令打开 VSCode 设置","content":"#\n\n终端尝试使用命令打开 VSCode 在终端用git命令打开VS code时 会出现 command not found 的情况 这时候需要打开VSCode\nVSCode文档提到，在VSCode执行shell command\n\n\n\n按下 ⌘+ shift + P 输入shell code 此时再输入 code .就可以顺利打开","routePath":"/my-rspress-app/guides/basic/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"通过home brew安装MongoDB","content":"#\n\n1.打开官网 前提是已经安装了home brew 打开终端 对照官网的内容遵循指令安装 1.安装相关工具\n\n\n\n2.更新brew\n\n\n\n3.安装community\n\n\n\n可以通过mongod --version 查看版本号码\n\n\n\n4.开启关闭服务\n\n\n\n5.查看端口 这时用的指令是\n\n\n\n以往是mongo\n\n回车后会显示默认端口的内容 关闭服务\n\n\n\n关闭后链接就失效了connect ECONNREFUSED\n\n\n\n6.强制关闭\n\n\n\n7.修改端口 比如我们修改为 27020 此语句的详细可查看官网 config 的位置如果电脑是M1 chip就是\n\n\n\n\n\n想要查看这个端口的相关内容不要用 mongosh 要用\n\n","routePath":"/my-rspress-app/guides/basic/introduction","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"node-版本管理","content":"#\n\n今天折腾了一下node版本管理。 使用nvm进行版本管理,但是在实行命令的过程中出现了很多错误。\n\n\n\n在nvm github上找到的命令\n\n\n\n\n\n这条语句同时会把之前安装过的版本也移植到nvm,但是个人还是重新用nvm装了之前的版本","routePath":"/my-rspress-app/guides/basic/nvm","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"相关文档","content":"使用 FFmpeg 合并 音频与视频#\n\n使用 哔哩哔哩下载助手 下载一些视频时发现想要更高清的只有单独的音频/视频\n\n懒得使用视频格式的软件\n\n于是便使用了 FFmpeg\n\n\n下载 FFmpeg#\n\n根据自己的系统下载 FFmpeg\n\n下载完成后解压此 zip\n\n然后将其移动到本机的环境变量路径所在文件夹里面，这样就能在任何位置使用 FFmpeg 命令了.\n\n打开终端，查看 FFmpeg 版本\n\n\n\n\n\n\n合并音频与视频#\n\n现在 我们有一个 音频 audio.m4s 和一个 纯视频 video.m4s 在所在位置打开终端，输入合并 为视频的命令.\n\n\n\n出现 这一行表示合并完成✅\n\n\n\n\n\n\n相关文档#\n\n更多 FFmpeg 使用方法请看 电子书FFmpeg 教程","routePath":"/my-rspress-app/guides/install/","lang":"","toc":[{"text":"使用 FFmpeg 合并 音频与视频","id":"使用-ffmpeg-合并-音频与视频","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"flutter","content":"#\n\nVScode 中 （Shift+Cmd+P）。开始输入“flutter new\"\n\n\n\n * runApp 把传入的的 Widget显示在屏幕上，Widget 是 abstract class只能创建子类\n * flutter中所有的页面显示元素都是Widget的子类,\n * MaterialApp主题，这样可以不用给Widget写方向，否则都要设置方向\n * MaterialApp 是主题,自带方向设置,所以他里面的包含的widget都不需要设置方向\n * 在你的pubspec.yaml文件的flutter部分中有一个uses-material-design: true，为了使用预定义的Material图标集\n\n\n\n\nconst#\n\nWidget的嵌套,这里演示 Center居中组件 里面 child参数 嵌套 文本框Text\n\n//注意函数返回类型不能不写,否则就变成dynamic 会报错\n\nconst 嵌套问题，最外层用了const，那么里面就不用加，如果里面有单独的不是const的，那么最外层不能是const\n\n\n\n\nscaffold#\n\n\n\n\n\nGestureDetector GestureDetector小部件没有视觉表示，而是检测用户进行的手势。\n当用户点击child时，GestureDetector调用其回调函数\n\n\nbuild#\n\n\nbuild 可以嵌套#\n\n\n\n更改界面 StatefulWidget中的build\n\n * stful cmd + i\n * stf 快速生成StatefulWidget\n * stl 快速生成StatelessWidget\n\n\n\n\nstate not working#\n\n\n\n正确示范\n\n\n\n\nstateless#\n\n * stl 快速生成StatelessWidget\n\n\n\n快捷键\n\n * 调出 Refactor 菜单。在 VS Code 中，您可以通过以下两种方式之一执行此操作：\n\n * 右键点击要重构的代码段（在本例中为 Text），然后从下拉菜单中选择 Refactor...， 或者\n\n * 将光标移到要重构的代码段上（在本例中为 Text），然后按下 Ctrl+. (Win/Linux) 或 Cmd+. (Mac)。\n\n * 在 Refactor 菜单中，选择 Extract Widget。指定一个名称，例如 BigCard，然后点击 Enter 键。\n\n这会在当前文件的末尾自动创建一个新的 BigCard 类。\n\n\nstate生命周期#\n\nstateless widget 没有生命周期\n\n\n\n响应小部件生命周期事件 在 StatefulWidget 上调用 createState() 后，框架会将新的状态对象插入到树中，然后调用状态对象的\ninitState()。 State 的子类可以重写 initState()，以执行只需要在初始化时发生的工作。 例如，可以重写 initState()\n来配置动画或订阅平台服务。实现 initState() 的必须以调用 super.initState 开头。 当不再需要状态对象时，框架会调用状态对象的\ndispose()。重写 dispose() 函数以执行清理工作。 例如，可以重写 dispose() 来取消定时器或取消订阅平台服务。dispose()\n的实现通常以调用 super.dispose 结束。\n\n\n布局#\n\n * Container\n\n\n\n * row\n\n\n\n * mainAxisAlignment: MainAxisAlignment.spaceEvenly,//均匀分布子控件,两边顶头也有空间\n\n * mainAxisAlignment: MainAxisAlignment.spaceBetween,//均匀分布子控件,两边顶头没有空间\n\n * mainAxisAlignment: MainAxisAlignment.spaceAround,//中间分布平均的控件,两边顶头的用一半的中间的空间\n\n * //交叉轴默认对齐方式是center ,主轴是start\n\n * crossAxisAlignment:\n   CrossAxisAlignment.stretch,//只有交叉轴有拉伸stretch是拉伸,下面container会被拉伸Text不会被拉伸\n\n * crossAxisAlignment: CrossAxisAlignment.start,//顶端对齐\n\n * crossAxisAlignment: CrossAxisAlignment.end,//交叉轴底部对齐\n\n> decoration 中声明 color 外部就不用 color\n\n> Scaffoldbody部分 内容显示在 appBar 的下方，位于环境 MediaQuery 的 MediaQueryData.viewInsets\n> 底部的上方， 在 floatingActionButton后方。 在drawer 的后方,点击左上角后,弹出会挡住body。 如果\n> resizeToAvoidBottomInset 设置为 false，那么当屏幕键盘出现时，body 的大小不会调整， 即不会被\n> viewInsets.bottom 缩进。 Scaffold 的 body 中的部件会定位在 app bar 和 Scaffold\n> 底部之间的可用空间的左上角。 居中显示，可以考虑将其放入 Center 部件中， 并让 Center 成为 body。如果你想让部件扩展以填充可用空间，\n> 如果有column列放在body里,可能会溢出,改成用ListView可以自动滚动,不会溢出./居中显示，可以考虑将其放入 Center\n> 部件中.当body中的子控件有自己的尺寸的时候,body取子控件的尺寸,并且左上角对其\n\nScaffold 中 body向内约束(Container )大小**\n\n 1. TextField\n\n\n\nCenter\n\n> 1.父控件有尺寸约束,优先用父控件的尺寸,Center会自动扩充到最大填充满父控件. 2.父控件没有尺寸约束,那么才看倍率因子,不能给负数\n> widthFactor 或 heightFactor 3.上下左右都居中,不能像Align那样可以随意改变对其方式\n> 4.如果外层没有container这种尺寸的约束,而是直接放在body的子控件,那么直接把center最大化\n\nImage","routePath":"/my-rspress-app/guides/install/project","lang":"","toc":[{"text":"const","id":"const","depth":2,"charIndex":316},{"text":"scaffold","id":"scaffold","depth":2,"charIndex":472},{"text":"build","id":"build","depth":2,"charIndex":578},{"text":"build 可以嵌套","id":"build-可以嵌套","depth":3,"charIndex":587},{"text":"state not working","id":"state-not-working","depth":3,"charIndex":704},{"text":"stateless","id":"stateless","depth":3,"charIndex":735},{"text":"state生命周期","id":"state生命周期","depth":3,"charIndex":1058},{"text":"布局","id":"布局","depth":2,"charIndex":1433}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"","content":"NOTE\n\n这是一个 note 类型的 block\n\n\n防抖截流#\n\n\n防抖#\n\n\n\n\n\n\n截流#\n\n\n\n\n区别#\n\n继承和原型链\n\n\nPromise#\n\nrevealing constructor Promise 的实现\n\n\n\n 1. 状态管理与数据存储 状态变量（state） Promise 内部有三个状态：\n\npending（等待）：初始状态，表示操作尚未完成。\n\nfulfilled（已成功）：操作成功完成。\n\nrejected（已拒绝）：操作失败。\n\n结果存储 当 Promise 状态改变时，成功的结果存储在 value 中，而失败的原因存储在 reason 中。这允许后续通过 then 方法获取对应的结果。\n\n回调队列 当 Promise 处于 pending 状态时，用户可能调用 then 注册回调函数。此时，由于 Promise\n尚未完成，就无法立即执行回调，因此需要将成功回调存放在 onFulfilledCallbacks 数组中，将失败回调存放在\nonRejectedCallbacks 数组中。\n\n 2. 构造函数和执行器 执行器函数（executor） 构造函数接收一个执行器 executor，并立即执行该函数，同时传入内部封装好的 resolve 和\n    reject 函数。如果 executor 中抛出异常，会自动调用 reject。\n\nresolve 和 reject 这两个方法只允许从 pending 状态转变到最终状态（fulfilled 或 rejected），这保证了 Promise\n的状态一旦改变就不可再变。 在状态改变后，通过 setTimeout 异步调用注册在回调队列中的回调函数，确保所有 then\n中的回调都是异步执行的（符合规范）。\n\n 3. then 方法及链式调用 参数处理 then 方法接受两个参数，分别为成功回调 onFulfilled 和失败回调\n    onRejected。如果用户没有传入相应的回调，会采用默认行为：\n\n成功回调默认返回原值。\n\n失败回调默认抛出错误，使错误能被后续的 catch 捕获。\n\n状态处理 在调用 then 时，根据当前 Promise 的状态：\n\n如果状态已经确定（fulfilled 或 rejected），则使用 setTimeout 异步调用相应的回调，并获取回调返回值，然后通过调用返回的新\nPromise 的 resolve 或 reject 将结果传递出去。\n\n如果状态还未确定（pending），则将回调函数存储到对应的队列中。一旦状态改变时，这些回调会被依次调用，并且通过返回值来决定新 Promise 的状态。\n\n链式调用 每次调用 then 都返回一个新的 Promise，这样就可以实现链式调用。通过在新 Promise 的 executor\n内部，根据上一次的回调执行结果决定调用 resolve 还是 reject，从而使得结果能逐层传递。\n\n 4. 异步执行 为了确保 Promise 的行为符合规范，所有回调函数都要异步执行，即使 Promise 已经处于确定状态，也通过 setTimeout\n    延迟执行。这是为了保证在代码执行过程中，注册回调的代码先运行完成，从而避免同步调用带来的问题。\n\n小结 这个示例实现涵盖了 Promise 的基本特性：\n\n状态不可逆转：状态从 pending 转变为 fulfilled 或 rejected 后不会改变。\n\n回调注册与执行：支持在状态未确定时注册回调，状态改变后异步执行所有对应回调。\n\n异常处理：在执行器函数和回调中抛出的异常会正确捕获并传递给后续的 reject。\n\n链式调用：通过 then 方法返回新的 Promise 实现链式调用，允许连续处理异步操作。\n\n\n实例方法#\n\nArray.prototype.map()\n\nmap() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\n\n由于 map 创建一个新数组，在没有使用返回的数组的情况下调用它是不恰当的；应该使用 forEach 或 for...of 作为代替。\n\n\n\n\nDeepCopy#\n\n深拷贝（Deep\nCopy）是指创建一个对象的新副本，复制对象及其所有嵌套对象或数组的内容，新对象与原对象完全独立，互不影响。以下是几种实现深拷贝的常见方法，适用于\nJavaScript： 1 JSON.parse(JSON.stringify(obj))\n\n\n\n 2. 使用递归实现深拷贝\n\n\n\n 3. 使用 Lodash 库的 cloneDeep 方法\n\n","routePath":"/my-rspress-app/guides/interview/interview","lang":"","toc":[{"text":"防抖截流","id":"防抖截流","depth":2,"charIndex":27},{"text":"防抖","id":"防抖","depth":3,"charIndex":35},{"text":"截流","id":"截流","depth":3,"charIndex":45},{"text":"区别","id":"区别","depth":3,"charIndex":53},{"text":"Promise","id":"promise","depth":2,"charIndex":67},{"text":"实例方法","id":"实例方法","depth":2,"charIndex":1588},{"text":"DeepCopy","id":"deepcopy","depth":2,"charIndex":1741}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"i nsat;;;;;;;","content":"#","routePath":"/my-rspress-app/guides/introduction/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"jfhsliahfiuhedi","content":"serhgtsdrtfd\n\nNOTE\n\n这是一个 note 类型的 block\n\n\njfhsliahfiuhedi#\n\njks.adjfj","routePath":"/my-rspress-app/guides/introduction/test","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"快捷键","content":"#\n\n\nvim#\n\nea 在单词后插入\n\nc：删除并进入 insert 模式 ch/dh 删除当前光标前一个字符\n\ncj/dj 删除当前光标所在行和下一行(一下子删两行)\n\n * d g _：删除到行尾\n\n * D\n\n * d e：删除到单词尾\n\n * d b：\n\n * e a：在当前单词后插入\n\n * bi 在单词前插入\n\n * d w：删除到下个单词前（\n\n * c w 功能相同，但会保留下个单词前的空格）\n\nxs :->del\n\n * x：删除当前光标所在字符\n * X：删除当前光标所在字符的前一个字符\n * s：删除当前光标所在字符并进入 insert mode\n * S：删除当前光标所在行的除缩进外的所有内容并进入 insert modec\n * 删掉除空格以外的这一行////dd\n * u: vim 中的 ctrl z\n * ctrl + r：重做 ctrl shift z vim-indent-object operator ai :操作于}之前\n\n操作{}内的，可以衍生操作一个函数。\n\n\n\n\nvisual mode#\n\nv模式 V:选中这一行 o:移动光标移动很方便 选中再操作\n\n\n搜索#\n\nno fucking way\n\n * oneline f or F:vfw\n\nt or T:d t w\n\n * 全局搜索\n\n> / or ?\n\n\n\n\n. %#\n\n\n\n * gd Go to Definition（跳转到定义） 数字点 批量重复操作\n\n选择批量替换 配合/\n\n * gh hover\n * gciw\n\n\nvscode#\n\n * 折叠代码：option + command + '['\n\n * C - w v\n\n * C - w s\n\n * C - w w changewindow\n\n * C - w c close window\n\n * Cmd W\n\n * C - w o close other windows\n\n * % () []\n\n * indent Object 基于缩进\n\n * cmd shift j mulit 多范围选择cmd up down切换\n\n * cmd p ->>>\n   \n   * > [cmd shift p]extensions\n   \n   * @[cmd t]\n   * #[cmd shift o]工作区 :排序\n\n * cmd t\n\n * cmd shift enter\n\n * cmd enter\n\n * option + delete：删除光标前的单词（一个文本块为一个单词，如 vimUser 这里为一个单词）\n\n * option + control + delete：删除光标前的单词（以驼峰为单词的区分，如 vimUser 这里为两个单词）\n\n * f8\n\n * cmd k r[reveal in finder]\n\n * cmd k p[copy path]\n\n\nMac#\n\n\nbasic#\n\ncommand + ,：打开设置页，绝大部分软件通用\n\ncommand + q：退出软件\n\ncommand + ctrl + q：锁屏\n\ncommand + tap / command + shift +\ntap：触发一次则快速切换到上一个使用的软件窗口，多次触发则会显示当前打开了的软件列表并向右切换，而 command + shift + tap 则是向左切换\n\ncommand + h：隐藏软件窗，隐藏后可以通过 command + tap 切换到该软件而让它显示出来；\n\ncommand + m：隐藏软件窗到底部 Dock 栏，隐藏后无法通过 command + tap 切换到该软件而让它显示出来；可以通过 command +\ntap 切换到该软件，松开 tab 但不松开 command，然后按下 option 键，即可让改软件重新从 Dock 调出来；\n\ncommand +`：切换同一个软件中的多个窗口，如 VScode 打开多个工作区窗口时即可用它切换；\n\ncontrol + [左 / 右方向键]：切换桌面；\n\n\nfinder#\n\n * ↓↑←→：选择文件\n * command + ↓ / command + o：进入文件夹或打开文件；\n * command + ↑：返回上一层；\n * command + [：后退；\n * command + ]：前进；\n * command + d：复制选中的文件；\n * command + i：显示选中的文件简介；\n * shift + command + n：新建文件夹；\n * command + delete：删除文件；\n * command + n：新建 Finder 窗口； 按住 option 同时移动文件到另一文件夹会拷贝该文件夹；","routePath":"/my-rspress-app/guides/shortcuts/","lang":"","toc":[{"text":"vim","id":"vim","depth":2,"charIndex":3},{"text":"visual mode","id":"visual-mode","depth":3,"charIndex":460},{"text":"搜索","id":"搜索","depth":3,"charIndex":506},{"text":". %","id":"-","depth":3,"charIndex":586},{"text":"vscode","id":"vscode","depth":2,"charIndex":670},{"text":"Mac","id":"mac","depth":2,"charIndex":1230},{"text":"basic","id":"basic","depth":3,"charIndex":1237},{"text":"finder","id":"finder","depth":3,"charIndex":1712}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"无需鼠标拖拽窗口","content":"#\n\n这个技巧非常好用，建议所有人开一下，在终端中输入： defaults write -g NSWindowShouldDragOnGesture YES ，\n然后回车，之后新打开的应用窗口，按住 Control+Command 键，即可在任意位置使用鼠标拖拽窗口，不用拖窗口顶部了, 但是不不适用于 finder\n之类的，总之配合 三指拖动 非常好用。","routePath":"/my-rspress-app/guides/tricks","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"main","content":"#","routePath":"/my-rspress-app/main","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]