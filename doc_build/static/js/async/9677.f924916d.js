"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["9677"],{2784:function(e,n,t){t.r(n),t.d(n,{default:()=>c});var i=t(6773),d=t(453),l=t(7031);function r(e){let n=Object.assign({div:"div",p:"p",code:"code",h2:"h2",a:"a",h3:"h3",pre:"pre",table:"table",tbody:"tbody",tr:"tr",th:"th",td:"td",strong:"strong",details:"details",summary:"summary",ul:"ul",li:"li"},(0,d.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(l.default,{text:"一些常见的面试题"}),"\n",(0,i.jsxs)(n.div,{className:"rspress-directive note",children:[(0,i.jsx)(n.div,{className:"rspress-directive-title",children:"NOTE"}),(0,i.jsx)(n.div,{className:"rspress-directive-content",children:(0,i.jsxs)(n.p,{children:["这是一个 ",(0,i.jsx)(n.code,{children:"note"})," 类型的 ",(0,i.jsx)(n.code,{children:"block"}),"\n"]})})]}),"\n",(0,i.jsxs)(n.h2,{id:"防抖截流",children:["防抖截流",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖截流",children:"#"})]}),"\n",(0,i.jsxs)(n.h3,{id:"防抖",children:["防抖",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖",children:"#"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            padding: 20px;\n        }\n        #inputField {\n            padding: 8px;\n            font-size: 16px;\n            width: 300px;\n        }\n        #output {\n            margin-top: 10px;\n            color: #333;\n        }\n        </style>\n</head>\n<body>\n    <h2>输入事件模拟（带防抖）</h2>\n    <input type="text" id="inputField" placeholder="请输入内容...">\n    <div id="output">结果将显示在这里</div>\n    <script src="./debounce.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 防抖函数用于限制函数的执行频率，常用于处理高频触发的事件（如窗口调整、输入框输入等），确保在事件停止触发一段时间后才执行一次。\nfunction debounce(fn, delay) {\n    let timer = null\n    return function (...args) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            fn(...args)\n            timer = null\n        }, delay)\n    }\n}\n// 获取 DOM 元素\nconst inputField = document.getElementById('inputField');\nconst output = document.getElementById('output');\n// 示例1: 模拟输入事件\nconst logInput = debounce((value) => {\n    output.textContent = `处理后的输入: ${value || '无内容'}`;\n    console.log(`输入值: ${value}`);\n}, 500);\n\n \n// 监听输入事件\ninputField.addEventListener('input', (event) => {\n    const value = event.target.value;\n    logInput(value);\n});\n// // 示例2: 窗口调整事件\nconst handleResize = debounce(() => {\n    console.log(\"窗口大小调整完成\");\n}, 300);\n\nwindow.addEventListener(\"resize\", handleResize); // 调整窗口时，只在停止调整 300ms 后执行\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"截流",children:["截流",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#截流",children:"#"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n\n</head>\n<body>\n    <input type="text" id="input">\n    <div id="content">content:</div>\n</body>\n<script type="text/javascript">\n    // 更清晰的实现（修正解构赋值问题）\nfunction handler() {\n    const inputElement = document.getElementById("input");\n    document.getElementById("content").innerHTML = `内容: ${inputElement.value}`;\n}\n\n// 标准节流函数实现（保留上下文绑定能力）\nconst throttle = (fn, wait) => {\n    let timer;\n    return function (...args) {\n        if (!timer) {\n            timer = setTimeout(() => {\n                fn.apply(this, args); // 绑定正确的 this 上下文\n                timer = null;\n            }, wait);\n        }\n    };\n};\ndocument.addEventListener(\'input\',throttle(handler,300))\n<\/script>\n</html>\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"区别",children:["区别",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#区别",children:"#"})]}),"\n",(0,i.jsx)("table",{className:"block bord...",children:(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"维度"}),(0,i.jsx)("th",{children:"防抖(Debounce)"}),(0,i.jsx)("th",{children:"节流(Throttle)"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)(n.strong,{children:"核心目标"})}),(0,i.jsx)("td",{children:"确保最终状态稳定后执行"}),(0,i.jsx)("td",{children:"确保固定间隔内最多执行一次"})]})]})}),"\n",(0,i.jsxs)("details",{children:[(0,i.jsx)("summary",{children:"\uD83D\uDCCC 使用场景说明"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"防抖"}),"：适用于需要等待用户停止操作后执行的场景（如搜索框输入联想）"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"节流"}),"：适用于需要限制操作频率的场景（如窗口resize事件、滚动事件）"]}),"\n"]})]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}let c=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["guides%2Finterview%2Finterview.mdx"]={toc:[{text:"防抖截流",id:"防抖截流",depth:2},{text:"防抖",id:"防抖",depth:3},{text:"截流",id:"截流",depth:3},{text:"区别",id:"区别",depth:3}],title:"",headingTitle:"",frontmatter:{}}},7031:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var i=t(6773);t(1699);let d=e=>{let{text:n}=e;return(0,i.jsx)("h1",{style:{fontSize:"2.5rem",fontWeight:"bold",color:"#333",textAlign:"center",margin:"20px 0",padding:"10px",borderBottom:"2px solid #eee"},children:n})}}}]);