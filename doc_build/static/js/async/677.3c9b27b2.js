"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["677"],{2784:function(n,e,t){t.r(e),t.d(e,{default:()=>c});var i=t(2676),d=t(453),r=t(6357);function l(n){let e=Object.assign({div:"div",p:"p",code:"code",h2:"h2",a:"a",h3:"h3",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,d.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.default,{text:"一些常见的面试题"}),"\n",(0,i.jsxs)(e.div,{className:"rspress-directive note",children:[(0,i.jsx)(e.div,{className:"rspress-directive-title",children:"NOTE"}),(0,i.jsx)(e.div,{className:"rspress-directive-content",children:(0,i.jsxs)(e.p,{children:["这是一个 ",(0,i.jsx)(e.code,{children:"note"})," 类型的 ",(0,i.jsx)(e.code,{children:"block"}),"\n"]})})]}),"\n",(0,i.jsxs)(e.h2,{id:"防抖截流",children:["防抖截流",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖截流",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"防抖",children:["防抖",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            padding: 20px;\n        }\n        #inputField {\n            padding: 8px;\n            font-size: 16px;\n            width: 300px;\n        }\n        #output {\n            margin-top: 10px;\n            color: #333;\n        }\n        </style>\n</head>\n<body>\n    <h2>输入事件模拟（带防抖）</h2>\n    <input type="text" id="inputField" placeholder="请输入内容...">\n    <div id="output">结果将显示在这里</div>\n    <script src="./debounce.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"// 防抖函数用于限制函数的执行频率，常用于处理高频触发的事件（如窗口调整、输入框输入等），确保在事件停止触发一段时间后才执行一次。\nfunction debounce(fn, delay) {\n    let timer = null\n    return function (...args) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            fn(...args)\n            timer = null\n        }, delay)\n    }\n}\n// 获取 DOM 元素\nconst inputField = document.getElementById('inputField');\nconst output = document.getElementById('output');\n// 示例1: 模拟输入事件\nconst logInput = debounce((value) => {\n    output.textContent = `处理后的输入: ${value || '无内容'}`;\n    console.log(`输入值: ${value}`);\n}, 500);\n\n \n// 监听输入事件\ninputField.addEventListener('input', (event) => {\n    const value = event.target.value;\n    logInput(value);\n});\n// // 示例2: 窗口调整事件\nconst handleResize = debounce(() => {\n    console.log(\"窗口大小调整完成\");\n}, 300);\n\nwindow.addEventListener(\"resize\", handleResize); // 调整窗口时，只在停止调整 300ms 后执行\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"截流",children:["截流",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#截流",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n\n</head>\n<body>\n    <input type="text" id="input">\n    <div id="content">content:</div>\n</body>\n<script type="text/javascript">\n    // 更清晰的实现（修正解构赋值问题）\nfunction handler() {\n    const inputElement = document.getElementById("input");\n    document.getElementById("content").innerHTML = `内容: ${inputElement.value}`;\n}\n\n// 标准节流函数实现（保留上下文绑定能力）\nconst throttle = (fn, wait) => {\n    let timer;\n    return function (...args) {\n        if (!timer) {\n            timer = setTimeout(() => {\n                fn.apply(this, args); // 绑定正确的 this 上下文\n                timer = null;\n            }, wait);\n        }\n    };\n};\ndocument.addEventListener(\'input\',throttle(handler,300))\n<\/script>\n</html>\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"区别",children:["区别",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#区别",children:"#"})]}),"\n",(0,i.jsxs)(e.table,{children:["\n",(0,i.jsxs)(e.thead,{children:["\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.th,{children:"维度"}),"\n",(0,i.jsx)(e.th,{children:"防抖(Debounce)"}),"\n",(0,i.jsx)(e.th,{children:"节流(Throttle)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.tbody,{children:["\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"核心目标"}),"\n",(0,i.jsx)(e.td,{children:"确保最终状态稳定后执行"}),"\n",(0,i.jsx)(e.td,{children:"确保固定间隔内最多执行一次"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"高频触发结果"}),"\n",(0,i.jsx)(e.td,{children:"只执行最后一次"}),"\n",(0,i.jsx)(e.td,{children:"按固定节奏执行"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"代码重点"}),"\n",(0,i.jsx)(e.td,{children:"清除定时器 + 重新计时"}),"\n",(0,i.jsx)(e.td,{children:"时间戳对比 + 固定间隔"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"适用场景"}),"\n",(0,i.jsx)(e.td,{children:"结果导向（如搜索建议）"}),"\n",(0,i.jsx)(e.td,{children:"过程控制（如滚动加载）"}),"\n"]}),"\n"]}),"\n"]})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}let c=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["guides%2Finterview%2Finterview.mdx"]={toc:[{text:"防抖截流",id:"防抖截流",depth:2},{text:"防抖",id:"防抖",depth:3},{text:"截流",id:"截流",depth:3},{text:"区别",id:"区别",depth:3}],title:"",headingTitle:"",frontmatter:{}}},6357:function(n,e,t){t.r(e),t.d(e,{default:()=>d});var i=t(2676);t(5271);let d=n=>{let{text:e}=n;return(0,i.jsx)("h1",{style:{fontSize:"2.5rem",fontWeight:"bold",color:"#333",textAlign:"center",margin:"20px 0",padding:"10px",borderBottom:"2px solid #eee"},children:e})}}}]);