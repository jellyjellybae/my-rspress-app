"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["9677"],{2784:function(n,e,t){t.r(e),t.d(e,{default:()=>c});var i=t(6773),d=t(453),l=t(7031);function s(n){let e=Object.assign({div:"div",p:"p",code:"code",h2:"h2",a:"a",h3:"h3",pre:"pre",strong:"strong",ul:"ul",li:"li"},(0,d.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(l.default,{text:"一些常见的面试题"}),"\n",(0,i.jsxs)(e.div,{className:"rspress-directive note",children:[(0,i.jsx)(e.div,{className:"rspress-directive-title",children:"NOTE"}),(0,i.jsx)(e.div,{className:"rspress-directive-content",children:(0,i.jsxs)(e.p,{children:["\n这是一个 ",(0,i.jsx)(e.code,{children:"note"})," 类型的 ",(0,i.jsx)(e.code,{children:"block"})]})})]}),"\n",(0,i.jsxs)(e.h2,{id:"防抖截流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖截流",children:"#"}),"防抖截流"]}),"\n",(0,i.jsxs)(e.h3,{id:"防抖",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖",children:"#"}),"防抖"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            padding: 20px;\n        }\n        #inputField {\n            padding: 8px;\n            font-size: 16px;\n            width: 300px;\n        }\n        #output {\n            margin-top: 10px;\n            color: #333;\n        }\n        </style>\n</head>\n<body>\n    <h2>输入事件模拟（带防抖）</h2>\n    <input type="text" id="inputField" placeholder="请输入内容...">\n    <div id="output">结果将显示在这里</div>\n    <script src="./debounce.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"// 防抖函数用于限制函数的执行频率，常用于处理高频触发的事件（如窗口调整、输入框输入等），确保在事件停止触发一段时间后才执行一次。\nfunction debounce(fn, delay) {\n    let timer = null\n    return function (...args) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            fn(...args)\n            timer = null\n        }, delay)\n    }\n}\n// 获取 DOM 元素\nconst inputField = document.getElementById('inputField');\nconst output = document.getElementById('output');\n// 示例1: 模拟输入事件\nconst logInput = debounce((value) => {\n    output.textContent = `处理后的输入: ${value || '无内容'}`;\n    console.log(`输入值: ${value}`);\n}, 500);\n\n \n// 监听输入事件\ninputField.addEventListener('input', (event) => {\n    const value = event.target.value;\n    logInput(value);\n});\n// // 示例2: 窗口调整事件\nconst handleResize = debounce(() => {\n    console.log(\"窗口大小调整完成\");\n}, 300);\n\nwindow.addEventListener(\"resize\", handleResize); // 调整窗口时，只在停止调整 300ms 后执行\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"截流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#截流",children:"#"}),"截流"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n\n</head>\n<body>\n    <input type="text" id="input">\n    <div id="content">content:</div>\n</body>\n<script type="text/javascript">\n    // 更清晰的实现（修正解构赋值问题）\nfunction handler() {\n    const inputElement = document.getElementById("input");\n    document.getElementById("content").innerHTML = `内容: ${inputElement.value}`;\n}\n\n// 标准节流函数实现（保留上下文绑定能力）\nconst throttle = (fn, wait) => {\n    let timer;\n    return function (...args) {\n        if (!timer) {\n            timer = setTimeout(() => {\n                fn.apply(this, args); // 绑定正确的 this 上下文\n                timer = null;\n            }, wait);\n        }\n    };\n};\ndocument.addEventListener(\'input\',throttle(handler,300))\n<\/script>\n</html>\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"区别",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#区别",children:"#"}),"区别"]}),"\n",(0,i.jsx)("table",{className:"block bord...",children:(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:["\n",(0,i.jsx)("th",{children:"维度"}),"\n",(0,i.jsx)("th",{children:"防抖(Debounce)"}),"\n",(0,i.jsx)("th",{children:"节流(Throttle)"}),"\n"]}),(0,i.jsxs)("tr",{children:["\n",(0,i.jsx)("td",{children:(0,i.jsx)(e.strong,{children:"核心目标"})}),"\n",(0,i.jsx)("td",{children:"确保最终状态稳定后执行"}),"\n",(0,i.jsx)("td",{children:"确保固定间隔内最多执行一次"}),"\n"]})]})}),"\n",(0,i.jsxs)("details",{children:[(0,i.jsx)("summary",{children:"\uD83D\uDCCC 使用场景说明"}),(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"防抖"}),"：适用于需要等待用户停止操作后执行的场景（如搜索框输入联想）"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"节流"}),"：适用于需要限制操作频率的场景（如窗口resize事件、滚动事件）"]}),"\n"]})]})]})}function r(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(s,n)})):s(n)}let c=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["guides%2Finterview%2Finterview.mdx"]={toc:[{id:"防抖截流",text:"防抖截流",depth:2},{id:"防抖",text:"防抖",depth:3},{id:"截流",text:"截流",depth:3},{id:"区别",text:"区别",depth:3}],title:"",headingTitle:"",frontmatter:{}}},7031:function(n,e,t){t.r(e),t.d(e,{default:()=>d});var i=t(6773);t(1699);let d=n=>{let{text:e}=n;return(0,i.jsx)("h1",{style:{fontSize:"2.5rem",fontWeight:"bold",color:"#333",textAlign:"center",margin:"20px 0",padding:"10px",borderBottom:"2px solid #eee"},children:e})}}}]);