"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["907"],{3036:function(n,e,t){t.r(e),t.d(e,{default:()=>a});var i=t(6773),r=t(453),l=t(354);function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",ul:"ul",li:"li",h2:"h2",strong:"strong",h3:"h3",blockquote:"blockquote",ol:"ol",em:"em"},(0,r.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsxs)(e.h1,{id:"flutter",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#flutter",children:"#"}),"flutter"]}),"\n",(0,i.jsx)(e.p,{children:'VScode 中 （Shift+Cmd+P）。开始输入“flutter new"'}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-flutter",children:"import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    Text(\n      (\"hello world\"),\n      textDirection: TextDirection.rtl,\n      style: TextStyle(fontSize: 100, color: Colors.white),\n    ),\n  );\n}\n\n// class MyApp(){\n\n// }\n\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["runApp 把传入的的 ",(0,i.jsx)(e.code,{children:"Widget"}),"显示在屏幕上，",(0,i.jsx)(e.code,{children:"Widget"})," 是 abstract class只能创建子类"]}),"\n",(0,i.jsx)(e.li,{children:"flutter中所有的页面显示元素都是Widget的子类,"}),"\n",(0,i.jsx)(e.li,{children:"MaterialApp主题，这样可以不用给Widget写方向，否则都要设置方向"}),"\n",(0,i.jsx)(e.li,{children:"MaterialApp 是主题,自带方向设置,所以他里面的包含的widget都不需要设置方向"}),"\n",(0,i.jsx)(e.li,{children:"在你的pubspec.yaml文件的flutter部分中有一个uses-material-design: true，为了使用预定义的Material图标集"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"ios/runner/info.plist\n\xb7\xb7\xb7\n<key>FLTEnableImpeller </key>\n	<false/>\n\xb7\xb7\xb7\n\n//pubspec.yaml文件\nname: my_app\nflutter:\n  uses-material-design: true\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(MaterialApp(\n  home:Text('appp',style: TextStyle(fontSize: 100, color: Colors.white)),\n\n));\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"const",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#const",children:"#"}),"const"]}),"\n",(0,i.jsx)(e.p,{children:"Widget的嵌套,这里演示 Center居中组件 里面 child参数 嵌套 文本框Text"}),"\n",(0,i.jsx)(e.p,{children:"//注意函数返回类型不能不写,否则就变成dynamic 会报错"}),"\n",(0,i.jsx)(e.p,{children:"const 嵌套问题，最外层用了const，那么里面就不用加，如果里面有单独的不是const的，那么最外层不能是const"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"import 'package:flutter/material.dart';\n\nvoid main() {\n  String str=\"baby\";\nrunApp(\n  MaterialApp(\n  home:Center( \n    child: \n    Text(str,style: const TextStyle(fontSize: 100, color: Colors.white)), )\n\n));\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"scaffold",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#scaffold",children:"#"}),"scaffold"]}),"\n",(0,i.jsx)(l.Z,Object.assign({code:"flowchart TB\n    subgraph flexibleSpace [flexibleSpace]\n        subgraph topGroup [ ]\n            direction TB\n            leading[leading]\n            title[title]\n            actions[actions]\n        end\n        bottom[bottom]\n    end"},{config:{}})),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",children:"void main() {\n  //变量在这里\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          // leading: Text(\"左侧\"),\n          leading: Icon(Icons.home),\n          title: Text(\"navbar \"),\n          actions: [Text('back'), Icon(Icons.add)],\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () {\n            print('点击了 ');\n          },\n          // child: Icon(Icons.add),\n          child: Text('click'),\n        ),\n        body: Row(\n          children: [\n            // Spacer(),//\n            TextButton(\n              onLongPress: (){\n                print('long press');\n              },\n              onPressed: () {\n                // print('TextBUtn点击了 ');\n              },\n              child: Text('click me right now'),\n            ),\n            TextButton(\n              onPressed: () {\n                print('TextBUtn点击了 ');\n              },\n              child:Icon(Icons.holiday_village) \n            ),\n           GestureDetector(\n              onDoubleTap: (){\n                print('双击了！！');\n              },\n              onLongPress: (){\n                print('长安了');\n              },\n            child:Text('Gensture')\n            ), \n          ],\n        ),\n      ),\n    ),\n  );\n}\n// class MyApp(){\n\n// }\n\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"GestureDetector"}),"\nGestureDetector小部件没有视觉表示，而是检测用户进行的手势。\n当用户点击child时，GestureDetector调用其回调函数"]}),"\n",(0,i.jsxs)(e.h2,{id:"build",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#build",children:"#"}),"build"]}),"\n",(0,i.jsxs)(e.h3,{id:"build-可以嵌套",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#build-可以嵌套",children:"#"}),"build 可以嵌套"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",children:'import \'package:flutter/material.dart\';\n\nmain(){\n  //runApp把home参数里面的Widget画到屏幕上\n    runApp(MaterialApp(home: Widget1()));\n}\nclass Widget1 extends StatelessWidget {\n  const Widget1({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Text("000"),\n        Text("111"),\n        Widget2(),\n      ],\n    );\n\n  }\n}\nclass Widget2 extends StatelessWidget {\n  const Widget2({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n\n    //这里Widget2对象把build里面返回的Widget作为Widget使用,\n    // 返回给上一层,所以上一层的row,就变成了 111 spacer 222\n    return Column(\n      children: [\n        Text("222"),\n        Widget3()\n      ],\n    );\n  }\n}\nclass Widget3 extends StatefulWidget {\n  const Widget3({super.key});\n  @override\n  State<Widget3> createState() => _Widget3State();\n}\n//build可以嵌套,把return的Widget一层层,向上返回\nclass _Widget3State extends State<Widget3> {\n  int i = 0;\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[Text("333"),ElevatedButton(onPressed: (){\n      print("${++i}");\n      setState(() {\n      });\n      }, child: Text("$i")//此处的i只能在 _Widget3State 里找\n      )\n      ]\n    );\n  }\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["更改界面 ",(0,i.jsx)(e.strong,{children:"StatefulWidget"}),"中的",(0,i.jsx)(e.strong,{children:"build"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"stful cmd + i"}),"\n",(0,i.jsx)(e.li,{children:"stf 快速生成StatefulWidget"}),"\n",(0,i.jsx)(e.li,{children:"stl 快速生成StatelessWidget"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",children:"import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n    home:Row(children: [\n    Text('44'),//这里不会被热启动 不在build里面\n    Spacer(),\n    MyApp( ),\n    ],) \n    ),\n\n  );\n}\n// class MyApp(){\nclass MyApp extends StatefulWidget {\n  const MyApp({super.key});\n\n  @override\n  State<MyApp> createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  @override\n  Widget build(BuildContext context) {\n    return Text('abc');//不写return 就写成箭头函数\n  }\n}\n\n// }\n\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"state-not-working",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#state-not-working",children:"#"}),"state not working"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",children:"import 'package:flutter/cupertino.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Row(\n        children: [\n          Text('54'), //这里不会被热启动 不在build里面\n          Spacer(),\n          MyApp(),\n        ],\n      ),\n    ),\n  );\n}\n\nclass MyApp extends StatefulWidget {\n  const MyApp({super.key});\n\n  @override\n  State<MyApp> createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int i = 0;\n  //热启动会刷新build方法里面的内容,不在build方法里面的内容不会被刷新\n  //build方法会把里面的内容,一层一层的向上返回,并且描述到屏幕上\n  @override\n  Widget build(BuildContext context) {\n    print('build 执行了');\n    return Row(\n      children: [\n        ElevatedButton(\n          onPressed: () {\n            print('btn click${++i}times');\n          },\n          child: Text(\"$i\"),\n        ),\n      ],\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"正确示范"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",meta:'title="main.dart" {13-15}',children:'\xb7\xb7\xb7\nclass _MyAppState extends State<MyApp> {\n  int i = 0;\n  //热启动会刷新build方法里面的内容,不在build方法里面的内容不会被刷新\n  //build方法会把里面的内容,一层一层的向上返回,并且描述到屏幕上\n  @override\n  Widget build(BuildContext context) {\n    print("build执行了");\n    return Row(children: [\n      Text("${i}"),\n      ElevatedButton(onPressed: (){\n        print("按钮点击了${++i}");\n        setState(() {\n          print("abc");\n        });\n      }, child:Text("$i") )\n    ],);\n  }\n}\n\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"stateless",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#stateless",children:"#"}),"stateless"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"stl 快速生成StatelessWidget"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",meta:'title="main.dart"{2,3}',children:'class Widget1 extends StatelessWidget{\n  // const Widget1({ super.key });//简写\n  const Widget1({Key? key}):super(key: key);//初始化列表的语法方法\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    return Text("000");\n  }\n\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"快捷键"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"调出 Refactor 菜单。在 VS Code 中，您可以通过以下两种方式之一执行此操作："}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"右键点击要重构的代码段（在本例中为 Text），然后从下拉菜单中选择 Refactor...，\n或者"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"将光标移到要重构的代码段上（在本例中为 Text），然后按下 Ctrl+. (Win/Linux) 或 Cmd+. (Mac)。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"在 Refactor 菜单中，选择 Extract Widget。指定一个名称，例如 BigCard，然后点击 Enter 键。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这会在当前文件的末尾自动创建一个新的 BigCard 类。"}),"\n",(0,i.jsxs)(e.h3,{id:"state生命周期",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#state生命周期",children:"#"}),"state生命周期"]}),"\n",(0,i.jsx)(e.p,{children:"stateless widget 没有生命周期"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",children:"class _HomePageState extends State<HomePage> {\n  @override\n  void initState() {\n    // TODO: implement initState\n    super.initState();\n    //必须调用\n  }\n  @override\n  Widget build(BuildContext context) {\n    return Text('abc');\n  }\n"})}),"\n",(0,i.jsx)(e.p,{children:"响应小部件生命周期事件\n在 StatefulWidget 上调用 createState() 后，框架会将新的状态对象插入到树中，然后调用状态对象的 initState()。\nState 的子类可以重写 initState()，以执行只需要在初始化时发生的工作。\n例如，可以重写 initState() 来配置动画或订阅平台服务。实现 initState() 的必须以调用 super.initState 开头。\n当不再需要状态对象时，框架会调用状态对象的 dispose()。重写 dispose() 函数以执行清理工作。\n例如，可以重写 dispose() 来取消定时器或取消订阅平台服务。dispose() 的实现通常以调用 super.dispose 结束。"}),"\n",(0,i.jsxs)(e.h2,{id:"布局",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#布局",children:"#"}),"布局"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Container"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",children:"    return Container(\n      width: double.maxFinite,\n      color: Colors.blue,\n      height: 100,\n      alignment: Alignment.center,//child居中对齐\n      child: Text('abc',style: TextStyle(fontSize: 40,color:Colors.deepOrange,backgroundColor: Colors.green)),\n      );\n       \n       or\n   return Container(\n          // width: double.maxFinite,//最大尺寸\n        width: 200,\n        height: 100,\n\n        // alignment: Alignment.bottomRight,//居中对齐\n        child: Text(\"abc\",\n            textAlign: TextAlign.center,//无法通过Text自己的居中来让Text居中到屏幕中间\n            style: TextStyle(fontSize: 40,color: Colors.yellow,backgroundColor: Colors.green)),\n      );\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"row"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",children:"    return Row(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        Text(\n          'abc',\n          style: TextStyle(\n            fontSize: 40,\n            color: Colors.deepOrange,\n            backgroundColor: Colors.green,\n          ),\n        ),\n      ],\n    );\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"mainAxisAlignment: MainAxisAlignment.spaceEvenly,//均匀分布子控件,两边顶头也有空间"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"mainAxisAlignment: MainAxisAlignment.spaceBetween,//均匀分布子控件,两边顶头没有空间"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"mainAxisAlignment: MainAxisAlignment.spaceAround,//中间分布平均的控件,两边顶头的用一半的中间的空间"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"//交叉轴默认对齐方式是center ,主轴是start"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"crossAxisAlignment: CrossAxisAlignment.stretch,//只有交叉轴有拉伸stretch是拉伸,下面container会被拉伸Text不会被拉伸"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"crossAxisAlignment: CrossAxisAlignment.start,//顶端对齐"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"crossAxisAlignment: CrossAxisAlignment.end,//交叉轴底部对齐"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"decoration 中声明 color 外部就不用 color"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Scaffoldbody部分 内容显示在 appBar 的下方，位于环境 MediaQuery 的 MediaQueryData.viewInsets 底部的上方，\n在 floatingActionButton后方。\n在drawer 的后方,点击左上角后,弹出会挡住body。\n如果 resizeToAvoidBottomInset 设置为 false，那么当屏幕键盘出现时，body 的大小不会调整，\n即不会被 viewInsets.bottom 缩进。\nScaffold 的 body 中的部件会定位在 app bar 和 Scaffold 底部之间的可用空间的左上角。\n居中显示，可以考虑将其放入 Center 部件中，\n并让 Center 成为 body。如果你想让部件扩展以填充可用空间，\n如果有column列放在body里,可能会溢出,改成用ListView可以自动滚动,不会溢出./居中显示，可以考虑将其放入 Center 部件中.当body中的子控件有自己的尺寸的时候,body取子控件的尺寸,并且左上角对其"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Scaffold 中 body向内约束(Container )大小"}),"**"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"TextField"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-dart",meta:"{2,14,15,17}",children:'class _HomePageState extends State<HomePage> {\n  var tc1 = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n   \n    return Container(\n      width: 1000,\n      height: 1000,\n      color: Colors.green,\n      \n      alignment: Alignment.topCenter,\n      child: TextField(\n        controller: tc1,\n        onChanged: (value) {\n          print("str=$value");\n          print("tc1=${ tc1.text }");  \n        },\n        decoration: InputDecoration(hintText: "input sth"),\n      ),\n      // child: Text("1111"),\n    );\n  }\n}\n\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:(0,i.jsx)(e.strong,{children:"Center"})})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"1.父控件有尺寸约束,优先用父控件的尺寸,Center会自动扩充到最大填充满父控件.\n2.父控件没有尺寸约束,那么才看倍率因子,不能给负数 widthFactor 或 heightFactor\n3.上下左右都居中,不能像Align那样可以随意改变对其方式\n4.如果外层没有container这种尺寸的约束,而是直接放在body的子控件,那么直接把center最大化"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:(0,i.jsx)(e.strong,{children:"Image"})})})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(s,n)})):s(n)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["guides%2Finstall%2Fproject.mdx"]={toc:[{id:"const",text:"const",depth:2},{id:"scaffold",text:"scaffold",depth:2},{id:"build",text:"build",depth:2},{id:"build-可以嵌套",text:"build 可以嵌套",depth:3},{id:"state-not-working",text:"state not working",depth:3},{id:"stateless",text:"stateless",depth:3},{id:"state生命周期",text:"state生命周期",depth:3},{id:"布局",text:"布局",depth:2}],title:"flutter",headingTitle:"flutter",frontmatter:{}}}}]);